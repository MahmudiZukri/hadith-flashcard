// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'string_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$StringFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StringFailureCopyWith<$Res> {
  factory $StringFailureCopyWith(
          StringFailure value, $Res Function(StringFailure) then) =
      _$StringFailureCopyWithImpl<$Res, StringFailure>;
}

/// @nodoc
class _$StringFailureCopyWithImpl<$Res, $Val extends StringFailure>
    implements $StringFailureCopyWith<$Res> {
  _$StringFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EmptyCopyWith<$Res> {
  factory _$$EmptyCopyWith(_$Empty value, $Res Function(_$Empty) then) =
      __$$EmptyCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$EmptyCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$Empty>
    implements _$$EmptyCopyWith<$Res> {
  __$$EmptyCopyWithImpl(_$Empty _value, $Res Function(_$Empty) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$Empty(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$Empty implements Empty {
  const _$Empty({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.empty(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Empty &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmptyCopyWith<_$Empty> get copyWith =>
      __$$EmptyCopyWithImpl<_$Empty>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return empty(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return empty?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class Empty implements StringFailure {
  const factory Empty({required final String? failedValue}) = _$Empty;

  String? get failedValue;
  @JsonKey(ignore: true)
  _$$EmptyCopyWith<_$Empty> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$HasWhitespaceCopyWith<$Res> {
  factory _$$HasWhitespaceCopyWith(
          _$HasWhitespace value, $Res Function(_$HasWhitespace) then) =
      __$$HasWhitespaceCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$HasWhitespaceCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$HasWhitespace>
    implements _$$HasWhitespaceCopyWith<$Res> {
  __$$HasWhitespaceCopyWithImpl(
      _$HasWhitespace _value, $Res Function(_$HasWhitespace) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$HasWhitespace(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$HasWhitespace implements HasWhitespace {
  const _$HasWhitespace({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.hasWhitespace(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HasWhitespace &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HasWhitespaceCopyWith<_$HasWhitespace> get copyWith =>
      __$$HasWhitespaceCopyWithImpl<_$HasWhitespace>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return hasWhitespace(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return hasWhitespace?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (hasWhitespace != null) {
      return hasWhitespace(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return hasWhitespace(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return hasWhitespace?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (hasWhitespace != null) {
      return hasWhitespace(this);
    }
    return orElse();
  }
}

abstract class HasWhitespace implements StringFailure {
  const factory HasWhitespace({required final String? failedValue}) =
      _$HasWhitespace;

  String? get failedValue;
  @JsonKey(ignore: true)
  _$$HasWhitespaceCopyWith<_$HasWhitespace> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$IsNotAlphanumericCopyWith<$Res> {
  factory _$$IsNotAlphanumericCopyWith(
          _$IsNotAlphanumeric value, $Res Function(_$IsNotAlphanumeric) then) =
      __$$IsNotAlphanumericCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$IsNotAlphanumericCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$IsNotAlphanumeric>
    implements _$$IsNotAlphanumericCopyWith<$Res> {
  __$$IsNotAlphanumericCopyWithImpl(
      _$IsNotAlphanumeric _value, $Res Function(_$IsNotAlphanumeric) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$IsNotAlphanumeric(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$IsNotAlphanumeric implements IsNotAlphanumeric {
  const _$IsNotAlphanumeric({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.isNotAlphanumeric(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IsNotAlphanumeric &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$IsNotAlphanumericCopyWith<_$IsNotAlphanumeric> get copyWith =>
      __$$IsNotAlphanumericCopyWithImpl<_$IsNotAlphanumeric>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return isNotAlphanumeric(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return isNotAlphanumeric?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (isNotAlphanumeric != null) {
      return isNotAlphanumeric(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return isNotAlphanumeric(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return isNotAlphanumeric?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (isNotAlphanumeric != null) {
      return isNotAlphanumeric(this);
    }
    return orElse();
  }
}

abstract class IsNotAlphanumeric implements StringFailure {
  const factory IsNotAlphanumeric({required final String? failedValue}) =
      _$IsNotAlphanumeric;

  String? get failedValue;
  @JsonKey(ignore: true)
  _$$IsNotAlphanumericCopyWith<_$IsNotAlphanumeric> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ExceedingLengthCopyWith<$Res> {
  factory _$$ExceedingLengthCopyWith(
          _$ExceedingLength value, $Res Function(_$ExceedingLength) then) =
      __$$ExceedingLengthCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue, int max});
}

/// @nodoc
class __$$ExceedingLengthCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$ExceedingLength>
    implements _$$ExceedingLengthCopyWith<$Res> {
  __$$ExceedingLengthCopyWithImpl(
      _$ExceedingLength _value, $Res Function(_$ExceedingLength) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
    Object? max = null,
  }) {
    return _then(_$ExceedingLength(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
      max: null == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ExceedingLength implements ExceedingLength {
  const _$ExceedingLength({required this.failedValue, required this.max});

  @override
  final String? failedValue;
  @override
  final int max;

  @override
  String toString() {
    return 'StringFailure.exceedingLength(failedValue: $failedValue, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExceedingLength &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue) &&
            (identical(other.max, max) || other.max == max));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue, max);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExceedingLengthCopyWith<_$ExceedingLength> get copyWith =>
      __$$ExceedingLengthCopyWithImpl<_$ExceedingLength>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return exceedingLength(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return exceedingLength?.call(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (exceedingLength != null) {
      return exceedingLength(failedValue, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return exceedingLength(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return exceedingLength?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (exceedingLength != null) {
      return exceedingLength(this);
    }
    return orElse();
  }
}

abstract class ExceedingLength implements StringFailure {
  const factory ExceedingLength(
      {required final String? failedValue,
      required final int max}) = _$ExceedingLength;

  String? get failedValue;
  int get max;
  @JsonKey(ignore: true)
  _$$ExceedingLengthCopyWith<_$ExceedingLength> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TooShortCopyWith<$Res> {
  factory _$$TooShortCopyWith(
          _$TooShort value, $Res Function(_$TooShort) then) =
      __$$TooShortCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue, int min});
}

/// @nodoc
class __$$TooShortCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$TooShort>
    implements _$$TooShortCopyWith<$Res> {
  __$$TooShortCopyWithImpl(_$TooShort _value, $Res Function(_$TooShort) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
    Object? min = null,
  }) {
    return _then(_$TooShort(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
      min: null == min
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$TooShort implements TooShort {
  const _$TooShort({required this.failedValue, required this.min});

  @override
  final String? failedValue;
  @override
  final int min;

  @override
  String toString() {
    return 'StringFailure.lengthTooShort(failedValue: $failedValue, min: $min)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TooShort &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue) &&
            (identical(other.min, min) || other.min == min));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue, min);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TooShortCopyWith<_$TooShort> get copyWith =>
      __$$TooShortCopyWithImpl<_$TooShort>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return lengthTooShort(failedValue, min);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return lengthTooShort?.call(failedValue, min);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (lengthTooShort != null) {
      return lengthTooShort(failedValue, min);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return lengthTooShort(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return lengthTooShort?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (lengthTooShort != null) {
      return lengthTooShort(this);
    }
    return orElse();
  }
}

abstract class TooShort implements StringFailure {
  const factory TooShort(
      {required final String? failedValue,
      required final int min}) = _$TooShort;

  String? get failedValue;
  int get min;
  @JsonKey(ignore: true)
  _$$TooShortCopyWith<_$TooShort> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WrongLengthCopyWith<$Res> {
  factory _$$WrongLengthCopyWith(
          _$WrongLength value, $Res Function(_$WrongLength) then) =
      __$$WrongLengthCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue, int length});
}

/// @nodoc
class __$$WrongLengthCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$WrongLength>
    implements _$$WrongLengthCopyWith<$Res> {
  __$$WrongLengthCopyWithImpl(
      _$WrongLength _value, $Res Function(_$WrongLength) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
    Object? length = null,
  }) {
    return _then(_$WrongLength(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$WrongLength implements WrongLength {
  const _$WrongLength({required this.failedValue, required this.length});

  @override
  final String? failedValue;
  @override
  final int length;

  @override
  String toString() {
    return 'StringFailure.wrongLength(failedValue: $failedValue, length: $length)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WrongLength &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue) &&
            (identical(other.length, length) || other.length == length));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue, length);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WrongLengthCopyWith<_$WrongLength> get copyWith =>
      __$$WrongLengthCopyWithImpl<_$WrongLength>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return wrongLength(failedValue, length);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return wrongLength?.call(failedValue, length);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (wrongLength != null) {
      return wrongLength(failedValue, length);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return wrongLength(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return wrongLength?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (wrongLength != null) {
      return wrongLength(this);
    }
    return orElse();
  }
}

abstract class WrongLength implements StringFailure {
  const factory WrongLength(
      {required final String? failedValue,
      required final int length}) = _$WrongLength;

  String? get failedValue;
  int get length;
  @JsonKey(ignore: true)
  _$$WrongLengthCopyWith<_$WrongLength> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MultilineCopyWith<$Res> {
  factory _$$MultilineCopyWith(
          _$Multiline value, $Res Function(_$Multiline) then) =
      __$$MultilineCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$MultilineCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$Multiline>
    implements _$$MultilineCopyWith<$Res> {
  __$$MultilineCopyWithImpl(
      _$Multiline _value, $Res Function(_$Multiline) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$Multiline(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$Multiline implements Multiline {
  const _$Multiline({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.multiline(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Multiline &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MultilineCopyWith<_$Multiline> get copyWith =>
      __$$MultilineCopyWithImpl<_$Multiline>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return multiline(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return multiline?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (multiline != null) {
      return multiline(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return multiline(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return multiline?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (multiline != null) {
      return multiline(this);
    }
    return orElse();
  }
}

abstract class Multiline implements StringFailure {
  const factory Multiline({required final String? failedValue}) = _$Multiline;

  String? get failedValue;
  @JsonKey(ignore: true)
  _$$MultilineCopyWith<_$Multiline> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ConfirmationNotMatchCopyWith<$Res> {
  factory _$$ConfirmationNotMatchCopyWith(_$ConfirmationNotMatch value,
          $Res Function(_$ConfirmationNotMatch) then) =
      __$$ConfirmationNotMatchCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue, String? failedConfirmationValue});
}

/// @nodoc
class __$$ConfirmationNotMatchCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$ConfirmationNotMatch>
    implements _$$ConfirmationNotMatchCopyWith<$Res> {
  __$$ConfirmationNotMatchCopyWithImpl(_$ConfirmationNotMatch _value,
      $Res Function(_$ConfirmationNotMatch) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
    Object? failedConfirmationValue = freezed,
  }) {
    return _then(_$ConfirmationNotMatch(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
      failedConfirmationValue: freezed == failedConfirmationValue
          ? _value.failedConfirmationValue
          : failedConfirmationValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$ConfirmationNotMatch implements ConfirmationNotMatch {
  const _$ConfirmationNotMatch(
      {required this.failedValue, required this.failedConfirmationValue});

  @override
  final String? failedValue;
  @override
  final String? failedConfirmationValue;

  @override
  String toString() {
    return 'StringFailure.confirmationNotMatch(failedValue: $failedValue, failedConfirmationValue: $failedConfirmationValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConfirmationNotMatch &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue) &&
            (identical(
                    other.failedConfirmationValue, failedConfirmationValue) ||
                other.failedConfirmationValue == failedConfirmationValue));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, failedValue, failedConfirmationValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ConfirmationNotMatchCopyWith<_$ConfirmationNotMatch> get copyWith =>
      __$$ConfirmationNotMatchCopyWithImpl<_$ConfirmationNotMatch>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return confirmationNotMatch(failedValue, failedConfirmationValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return confirmationNotMatch?.call(failedValue, failedConfirmationValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (confirmationNotMatch != null) {
      return confirmationNotMatch(failedValue, failedConfirmationValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return confirmationNotMatch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return confirmationNotMatch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (confirmationNotMatch != null) {
      return confirmationNotMatch(this);
    }
    return orElse();
  }
}

abstract class ConfirmationNotMatch implements StringFailure {
  const factory ConfirmationNotMatch(
      {required final String? failedValue,
      required final String? failedConfirmationValue}) = _$ConfirmationNotMatch;

  String? get failedValue;
  String? get failedConfirmationValue;
  @JsonKey(ignore: true)
  _$$ConfirmationNotMatchCopyWith<_$ConfirmationNotMatch> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidPhoneCopyWith<$Res> {
  factory _$$InvalidPhoneCopyWith(
          _$InvalidPhone value, $Res Function(_$InvalidPhone) then) =
      __$$InvalidPhoneCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$InvalidPhoneCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$InvalidPhone>
    implements _$$InvalidPhoneCopyWith<$Res> {
  __$$InvalidPhoneCopyWithImpl(
      _$InvalidPhone _value, $Res Function(_$InvalidPhone) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidPhone(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidPhone implements InvalidPhone {
  const _$InvalidPhone({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.invalidPhone(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidPhone &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidPhoneCopyWith<_$InvalidPhone> get copyWith =>
      __$$InvalidPhoneCopyWithImpl<_$InvalidPhone>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return invalidPhone(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return invalidPhone?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidPhone != null) {
      return invalidPhone(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return invalidPhone(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return invalidPhone?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidPhone != null) {
      return invalidPhone(this);
    }
    return orElse();
  }
}

abstract class InvalidPhone implements StringFailure {
  const factory InvalidPhone({required final String? failedValue}) =
      _$InvalidPhone;

  String? get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidPhoneCopyWith<_$InvalidPhone> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidEmailCopyWith<$Res> {
  factory _$$InvalidEmailCopyWith(
          _$InvalidEmail value, $Res Function(_$InvalidEmail) then) =
      __$$InvalidEmailCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$InvalidEmailCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$InvalidEmail>
    implements _$$InvalidEmailCopyWith<$Res> {
  __$$InvalidEmailCopyWithImpl(
      _$InvalidEmail _value, $Res Function(_$InvalidEmail) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidEmail(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidEmail implements InvalidEmail {
  const _$InvalidEmail({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.invalidEmail(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidEmail &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidEmailCopyWith<_$InvalidEmail> get copyWith =>
      __$$InvalidEmailCopyWithImpl<_$InvalidEmail>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return invalidEmail(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return invalidEmail?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return invalidEmail?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmail implements StringFailure {
  const factory InvalidEmail({required final String? failedValue}) =
      _$InvalidEmail;

  String? get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidEmailCopyWith<_$InvalidEmail> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidUrlCopyWith<$Res> {
  factory _$$InvalidUrlCopyWith(
          _$InvalidUrl value, $Res Function(_$InvalidUrl) then) =
      __$$InvalidUrlCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$InvalidUrlCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$InvalidUrl>
    implements _$$InvalidUrlCopyWith<$Res> {
  __$$InvalidUrlCopyWithImpl(
      _$InvalidUrl _value, $Res Function(_$InvalidUrl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidUrl(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidUrl implements InvalidUrl {
  const _$InvalidUrl({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.invalidUrl(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidUrl &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidUrlCopyWith<_$InvalidUrl> get copyWith =>
      __$$InvalidUrlCopyWithImpl<_$InvalidUrl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return invalidUrl(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return invalidUrl?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidUrl != null) {
      return invalidUrl(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return invalidUrl(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return invalidUrl?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidUrl != null) {
      return invalidUrl(this);
    }
    return orElse();
  }
}

abstract class InvalidUrl implements StringFailure {
  const factory InvalidUrl({required final String? failedValue}) = _$InvalidUrl;

  String? get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidUrlCopyWith<_$InvalidUrl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidSKUCopyWith<$Res> {
  factory _$$InvalidSKUCopyWith(
          _$InvalidSKU value, $Res Function(_$InvalidSKU) then) =
      __$$InvalidSKUCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$InvalidSKUCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$InvalidSKU>
    implements _$$InvalidSKUCopyWith<$Res> {
  __$$InvalidSKUCopyWithImpl(
      _$InvalidSKU _value, $Res Function(_$InvalidSKU) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidSKU(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidSKU implements InvalidSKU {
  const _$InvalidSKU({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.invalidSKU(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidSKU &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidSKUCopyWith<_$InvalidSKU> get copyWith =>
      __$$InvalidSKUCopyWithImpl<_$InvalidSKU>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return invalidSKU(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return invalidSKU?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidSKU != null) {
      return invalidSKU(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return invalidSKU(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return invalidSKU?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidSKU != null) {
      return invalidSKU(this);
    }
    return orElse();
  }
}

abstract class InvalidSKU implements StringFailure {
  const factory InvalidSKU({required final String? failedValue}) = _$InvalidSKU;

  String? get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidSKUCopyWith<_$InvalidSKU> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidDateTimeCopyWith<$Res> {
  factory _$$InvalidDateTimeCopyWith(
          _$InvalidDateTime value, $Res Function(_$InvalidDateTime) then) =
      __$$InvalidDateTimeCopyWithImpl<$Res>;
  @useResult
  $Res call({DateTime failedValue, String pattern});
}

/// @nodoc
class __$$InvalidDateTimeCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$InvalidDateTime>
    implements _$$InvalidDateTimeCopyWith<$Res> {
  __$$InvalidDateTimeCopyWithImpl(
      _$InvalidDateTime _value, $Res Function(_$InvalidDateTime) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = null,
    Object? pattern = null,
  }) {
    return _then(_$InvalidDateTime(
      failedValue: null == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as DateTime,
      pattern: null == pattern
          ? _value.pattern
          : pattern // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$InvalidDateTime implements InvalidDateTime {
  const _$InvalidDateTime({required this.failedValue, required this.pattern});

  @override
  final DateTime failedValue;
  @override
  final String pattern;

  @override
  String toString() {
    return 'StringFailure.invalidDateTime(failedValue: $failedValue, pattern: $pattern)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidDateTime &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue) &&
            (identical(other.pattern, pattern) || other.pattern == pattern));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue, pattern);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidDateTimeCopyWith<_$InvalidDateTime> get copyWith =>
      __$$InvalidDateTimeCopyWithImpl<_$InvalidDateTime>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return invalidDateTime(failedValue, pattern);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return invalidDateTime?.call(failedValue, pattern);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidDateTime != null) {
      return invalidDateTime(failedValue, pattern);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return invalidDateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return invalidDateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidDateTime != null) {
      return invalidDateTime(this);
    }
    return orElse();
  }
}

abstract class InvalidDateTime implements StringFailure {
  const factory InvalidDateTime(
      {required final DateTime failedValue,
      required final String pattern}) = _$InvalidDateTime;

  DateTime get failedValue;
  String get pattern;
  @JsonKey(ignore: true)
  _$$InvalidDateTimeCopyWith<_$InvalidDateTime> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidPersonNameCopyWith<$Res> {
  factory _$$InvalidPersonNameCopyWith(
          _$InvalidPersonName value, $Res Function(_$InvalidPersonName) then) =
      __$$InvalidPersonNameCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$InvalidPersonNameCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$InvalidPersonName>
    implements _$$InvalidPersonNameCopyWith<$Res> {
  __$$InvalidPersonNameCopyWithImpl(
      _$InvalidPersonName _value, $Res Function(_$InvalidPersonName) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidPersonName(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidPersonName implements InvalidPersonName {
  const _$InvalidPersonName({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.invalidPersonName(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidPersonName &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidPersonNameCopyWith<_$InvalidPersonName> get copyWith =>
      __$$InvalidPersonNameCopyWithImpl<_$InvalidPersonName>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return invalidPersonName(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return invalidPersonName?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidPersonName != null) {
      return invalidPersonName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return invalidPersonName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return invalidPersonName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidPersonName != null) {
      return invalidPersonName(this);
    }
    return orElse();
  }
}

abstract class InvalidPersonName implements StringFailure {
  const factory InvalidPersonName({required final String? failedValue}) =
      _$InvalidPersonName;

  String? get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidPersonNameCopyWith<_$InvalidPersonName> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ShortTokenCopyWith<$Res> {
  factory _$$ShortTokenCopyWith(
          _$ShortToken value, $Res Function(_$ShortToken) then) =
      __$$ShortTokenCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$ShortTokenCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$ShortToken>
    implements _$$ShortTokenCopyWith<$Res> {
  __$$ShortTokenCopyWithImpl(
      _$ShortToken _value, $Res Function(_$ShortToken) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$ShortToken(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$ShortToken implements ShortToken {
  const _$ShortToken({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.shortToken(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ShortToken &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ShortTokenCopyWith<_$ShortToken> get copyWith =>
      __$$ShortTokenCopyWithImpl<_$ShortToken>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return shortToken(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return shortToken?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (shortToken != null) {
      return shortToken(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return shortToken(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return shortToken?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (shortToken != null) {
      return shortToken(this);
    }
    return orElse();
  }
}

abstract class ShortToken implements StringFailure {
  const factory ShortToken({required final String? failedValue}) = _$ShortToken;

  String? get failedValue;
  @JsonKey(ignore: true)
  _$$ShortTokenCopyWith<_$ShortToken> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidTimeCopyWith<$Res> {
  factory _$$InvalidTimeCopyWith(
          _$InvalidTime value, $Res Function(_$InvalidTime) then) =
      __$$InvalidTimeCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$InvalidTimeCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$InvalidTime>
    implements _$$InvalidTimeCopyWith<$Res> {
  __$$InvalidTimeCopyWithImpl(
      _$InvalidTime _value, $Res Function(_$InvalidTime) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidTime(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidTime implements InvalidTime {
  const _$InvalidTime({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.invalidTime(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidTime &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidTimeCopyWith<_$InvalidTime> get copyWith =>
      __$$InvalidTimeCopyWithImpl<_$InvalidTime>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return invalidTime(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return invalidTime?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidTime != null) {
      return invalidTime(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return invalidTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return invalidTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidTime != null) {
      return invalidTime(this);
    }
    return orElse();
  }
}

abstract class InvalidTime implements StringFailure {
  const factory InvalidTime({required final String? failedValue}) =
      _$InvalidTime;

  String? get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidTimeCopyWith<_$InvalidTime> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidDateCopyWith<$Res> {
  factory _$$InvalidDateCopyWith(
          _$InvalidDate value, $Res Function(_$InvalidDate) then) =
      __$$InvalidDateCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$InvalidDateCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$InvalidDate>
    implements _$$InvalidDateCopyWith<$Res> {
  __$$InvalidDateCopyWithImpl(
      _$InvalidDate _value, $Res Function(_$InvalidDate) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidDate(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidDate implements InvalidDate {
  const _$InvalidDate({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.invalidDate(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidDate &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidDateCopyWith<_$InvalidDate> get copyWith =>
      __$$InvalidDateCopyWithImpl<_$InvalidDate>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(String? failedValue) invalidSKU,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return invalidDate(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(String? failedValue)? invalidSKU,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return invalidDate?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(String? failedValue)? invalidSKU,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidDate != null) {
      return invalidDate(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidSKU value) invalidSKU,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return invalidDate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidSKU value)? invalidSKU,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return invalidDate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidSKU value)? invalidSKU,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidDate != null) {
      return invalidDate(this);
    }
    return orElse();
  }
}

abstract class InvalidDate implements StringFailure {
  const factory InvalidDate({required final String? failedValue}) =
      _$InvalidDate;

  String? get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidDateCopyWith<_$InvalidDate> get copyWith =>
      throw _privateConstructorUsedError;
}
