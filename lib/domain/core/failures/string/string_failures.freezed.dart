// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, non_nullable_equals_parameter
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'string_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$StringFailure {
  Object? get failedValue => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StringFailureCopyWith<$Res> {
  factory $StringFailureCopyWith(
          StringFailure value, $Res Function(StringFailure) then) =
      _$StringFailureCopyWithImpl<$Res, StringFailure>;
}

/// @nodoc
class _$StringFailureCopyWithImpl<$Res, $Val extends StringFailure>
    implements $StringFailureCopyWith<$Res> {
  _$StringFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EmptyImplCopyWith<$Res> {
  factory _$$EmptyImplCopyWith(
          _$EmptyImpl value, $Res Function(_$EmptyImpl) then) =
      __$$EmptyImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$EmptyImplCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$EmptyImpl>
    implements _$$EmptyImplCopyWith<$Res> {
  __$$EmptyImplCopyWithImpl(
      _$EmptyImpl _value, $Res Function(_$EmptyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$EmptyImpl(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$EmptyImpl implements Empty {
  const _$EmptyImpl({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.empty(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmptyImpl &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmptyImplCopyWith<_$EmptyImpl> get copyWith =>
      __$$EmptyImplCopyWithImpl<_$EmptyImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return empty(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return empty?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class Empty implements StringFailure {
  const factory Empty({required final String? failedValue}) = _$EmptyImpl;

  @override
  String? get failedValue;
  @JsonKey(ignore: true)
  _$$EmptyImplCopyWith<_$EmptyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$HasWhitespaceImplCopyWith<$Res> {
  factory _$$HasWhitespaceImplCopyWith(
          _$HasWhitespaceImpl value, $Res Function(_$HasWhitespaceImpl) then) =
      __$$HasWhitespaceImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$HasWhitespaceImplCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$HasWhitespaceImpl>
    implements _$$HasWhitespaceImplCopyWith<$Res> {
  __$$HasWhitespaceImplCopyWithImpl(
      _$HasWhitespaceImpl _value, $Res Function(_$HasWhitespaceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$HasWhitespaceImpl(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$HasWhitespaceImpl implements HasWhitespace {
  const _$HasWhitespaceImpl({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.hasWhitespace(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HasWhitespaceImpl &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HasWhitespaceImplCopyWith<_$HasWhitespaceImpl> get copyWith =>
      __$$HasWhitespaceImplCopyWithImpl<_$HasWhitespaceImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return hasWhitespace(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return hasWhitespace?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (hasWhitespace != null) {
      return hasWhitespace(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return hasWhitespace(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return hasWhitespace?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (hasWhitespace != null) {
      return hasWhitespace(this);
    }
    return orElse();
  }
}

abstract class HasWhitespace implements StringFailure {
  const factory HasWhitespace({required final String? failedValue}) =
      _$HasWhitespaceImpl;

  @override
  String? get failedValue;
  @JsonKey(ignore: true)
  _$$HasWhitespaceImplCopyWith<_$HasWhitespaceImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$IsNotAlphanumericImplCopyWith<$Res> {
  factory _$$IsNotAlphanumericImplCopyWith(_$IsNotAlphanumericImpl value,
          $Res Function(_$IsNotAlphanumericImpl) then) =
      __$$IsNotAlphanumericImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$IsNotAlphanumericImplCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$IsNotAlphanumericImpl>
    implements _$$IsNotAlphanumericImplCopyWith<$Res> {
  __$$IsNotAlphanumericImplCopyWithImpl(_$IsNotAlphanumericImpl _value,
      $Res Function(_$IsNotAlphanumericImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$IsNotAlphanumericImpl(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$IsNotAlphanumericImpl implements IsNotAlphanumeric {
  const _$IsNotAlphanumericImpl({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.isNotAlphanumeric(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IsNotAlphanumericImpl &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$IsNotAlphanumericImplCopyWith<_$IsNotAlphanumericImpl> get copyWith =>
      __$$IsNotAlphanumericImplCopyWithImpl<_$IsNotAlphanumericImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return isNotAlphanumeric(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return isNotAlphanumeric?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (isNotAlphanumeric != null) {
      return isNotAlphanumeric(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return isNotAlphanumeric(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return isNotAlphanumeric?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (isNotAlphanumeric != null) {
      return isNotAlphanumeric(this);
    }
    return orElse();
  }
}

abstract class IsNotAlphanumeric implements StringFailure {
  const factory IsNotAlphanumeric({required final String? failedValue}) =
      _$IsNotAlphanumericImpl;

  @override
  String? get failedValue;
  @JsonKey(ignore: true)
  _$$IsNotAlphanumericImplCopyWith<_$IsNotAlphanumericImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ExceedingLengthImplCopyWith<$Res> {
  factory _$$ExceedingLengthImplCopyWith(_$ExceedingLengthImpl value,
          $Res Function(_$ExceedingLengthImpl) then) =
      __$$ExceedingLengthImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue, int max});
}

/// @nodoc
class __$$ExceedingLengthImplCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$ExceedingLengthImpl>
    implements _$$ExceedingLengthImplCopyWith<$Res> {
  __$$ExceedingLengthImplCopyWithImpl(
      _$ExceedingLengthImpl _value, $Res Function(_$ExceedingLengthImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
    Object? max = null,
  }) {
    return _then(_$ExceedingLengthImpl(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
      max: null == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ExceedingLengthImpl implements ExceedingLength {
  const _$ExceedingLengthImpl({required this.failedValue, required this.max});

  @override
  final String? failedValue;
  @override
  final int max;

  @override
  String toString() {
    return 'StringFailure.exceedingLength(failedValue: $failedValue, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExceedingLengthImpl &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue) &&
            (identical(other.max, max) || other.max == max));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue, max);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExceedingLengthImplCopyWith<_$ExceedingLengthImpl> get copyWith =>
      __$$ExceedingLengthImplCopyWithImpl<_$ExceedingLengthImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return exceedingLength(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return exceedingLength?.call(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (exceedingLength != null) {
      return exceedingLength(failedValue, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return exceedingLength(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return exceedingLength?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (exceedingLength != null) {
      return exceedingLength(this);
    }
    return orElse();
  }
}

abstract class ExceedingLength implements StringFailure {
  const factory ExceedingLength(
      {required final String? failedValue,
      required final int max}) = _$ExceedingLengthImpl;

  @override
  String? get failedValue;
  int get max;
  @JsonKey(ignore: true)
  _$$ExceedingLengthImplCopyWith<_$ExceedingLengthImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TooShortImplCopyWith<$Res> {
  factory _$$TooShortImplCopyWith(
          _$TooShortImpl value, $Res Function(_$TooShortImpl) then) =
      __$$TooShortImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue, int min});
}

/// @nodoc
class __$$TooShortImplCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$TooShortImpl>
    implements _$$TooShortImplCopyWith<$Res> {
  __$$TooShortImplCopyWithImpl(
      _$TooShortImpl _value, $Res Function(_$TooShortImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
    Object? min = null,
  }) {
    return _then(_$TooShortImpl(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
      min: null == min
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$TooShortImpl implements TooShort {
  const _$TooShortImpl({required this.failedValue, required this.min});

  @override
  final String? failedValue;
  @override
  final int min;

  @override
  String toString() {
    return 'StringFailure.lengthTooShort(failedValue: $failedValue, min: $min)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TooShortImpl &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue) &&
            (identical(other.min, min) || other.min == min));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue, min);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TooShortImplCopyWith<_$TooShortImpl> get copyWith =>
      __$$TooShortImplCopyWithImpl<_$TooShortImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return lengthTooShort(failedValue, min);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return lengthTooShort?.call(failedValue, min);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (lengthTooShort != null) {
      return lengthTooShort(failedValue, min);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return lengthTooShort(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return lengthTooShort?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (lengthTooShort != null) {
      return lengthTooShort(this);
    }
    return orElse();
  }
}

abstract class TooShort implements StringFailure {
  const factory TooShort(
      {required final String? failedValue,
      required final int min}) = _$TooShortImpl;

  @override
  String? get failedValue;
  int get min;
  @JsonKey(ignore: true)
  _$$TooShortImplCopyWith<_$TooShortImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WrongLengthImplCopyWith<$Res> {
  factory _$$WrongLengthImplCopyWith(
          _$WrongLengthImpl value, $Res Function(_$WrongLengthImpl) then) =
      __$$WrongLengthImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue, int length});
}

/// @nodoc
class __$$WrongLengthImplCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$WrongLengthImpl>
    implements _$$WrongLengthImplCopyWith<$Res> {
  __$$WrongLengthImplCopyWithImpl(
      _$WrongLengthImpl _value, $Res Function(_$WrongLengthImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
    Object? length = null,
  }) {
    return _then(_$WrongLengthImpl(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$WrongLengthImpl implements WrongLength {
  const _$WrongLengthImpl({required this.failedValue, required this.length});

  @override
  final String? failedValue;
  @override
  final int length;

  @override
  String toString() {
    return 'StringFailure.wrongLength(failedValue: $failedValue, length: $length)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WrongLengthImpl &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue) &&
            (identical(other.length, length) || other.length == length));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue, length);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WrongLengthImplCopyWith<_$WrongLengthImpl> get copyWith =>
      __$$WrongLengthImplCopyWithImpl<_$WrongLengthImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return wrongLength(failedValue, length);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return wrongLength?.call(failedValue, length);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (wrongLength != null) {
      return wrongLength(failedValue, length);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return wrongLength(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return wrongLength?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (wrongLength != null) {
      return wrongLength(this);
    }
    return orElse();
  }
}

abstract class WrongLength implements StringFailure {
  const factory WrongLength(
      {required final String? failedValue,
      required final int length}) = _$WrongLengthImpl;

  @override
  String? get failedValue;
  int get length;
  @JsonKey(ignore: true)
  _$$WrongLengthImplCopyWith<_$WrongLengthImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MultilineImplCopyWith<$Res> {
  factory _$$MultilineImplCopyWith(
          _$MultilineImpl value, $Res Function(_$MultilineImpl) then) =
      __$$MultilineImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$MultilineImplCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$MultilineImpl>
    implements _$$MultilineImplCopyWith<$Res> {
  __$$MultilineImplCopyWithImpl(
      _$MultilineImpl _value, $Res Function(_$MultilineImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$MultilineImpl(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$MultilineImpl implements Multiline {
  const _$MultilineImpl({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.multiline(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MultilineImpl &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MultilineImplCopyWith<_$MultilineImpl> get copyWith =>
      __$$MultilineImplCopyWithImpl<_$MultilineImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return multiline(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return multiline?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (multiline != null) {
      return multiline(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return multiline(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return multiline?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (multiline != null) {
      return multiline(this);
    }
    return orElse();
  }
}

abstract class Multiline implements StringFailure {
  const factory Multiline({required final String? failedValue}) =
      _$MultilineImpl;

  @override
  String? get failedValue;
  @JsonKey(ignore: true)
  _$$MultilineImplCopyWith<_$MultilineImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ConfirmationNotMatchImplCopyWith<$Res> {
  factory _$$ConfirmationNotMatchImplCopyWith(_$ConfirmationNotMatchImpl value,
          $Res Function(_$ConfirmationNotMatchImpl) then) =
      __$$ConfirmationNotMatchImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue, String? failedConfirmationValue});
}

/// @nodoc
class __$$ConfirmationNotMatchImplCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$ConfirmationNotMatchImpl>
    implements _$$ConfirmationNotMatchImplCopyWith<$Res> {
  __$$ConfirmationNotMatchImplCopyWithImpl(_$ConfirmationNotMatchImpl _value,
      $Res Function(_$ConfirmationNotMatchImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
    Object? failedConfirmationValue = freezed,
  }) {
    return _then(_$ConfirmationNotMatchImpl(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
      failedConfirmationValue: freezed == failedConfirmationValue
          ? _value.failedConfirmationValue
          : failedConfirmationValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$ConfirmationNotMatchImpl implements ConfirmationNotMatch {
  const _$ConfirmationNotMatchImpl(
      {required this.failedValue, required this.failedConfirmationValue});

  @override
  final String? failedValue;
  @override
  final String? failedConfirmationValue;

  @override
  String toString() {
    return 'StringFailure.confirmationNotMatch(failedValue: $failedValue, failedConfirmationValue: $failedConfirmationValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConfirmationNotMatchImpl &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue) &&
            (identical(
                    other.failedConfirmationValue, failedConfirmationValue) ||
                other.failedConfirmationValue == failedConfirmationValue));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, failedValue, failedConfirmationValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ConfirmationNotMatchImplCopyWith<_$ConfirmationNotMatchImpl>
      get copyWith =>
          __$$ConfirmationNotMatchImplCopyWithImpl<_$ConfirmationNotMatchImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return confirmationNotMatch(failedValue, failedConfirmationValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return confirmationNotMatch?.call(failedValue, failedConfirmationValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (confirmationNotMatch != null) {
      return confirmationNotMatch(failedValue, failedConfirmationValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return confirmationNotMatch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return confirmationNotMatch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (confirmationNotMatch != null) {
      return confirmationNotMatch(this);
    }
    return orElse();
  }
}

abstract class ConfirmationNotMatch implements StringFailure {
  const factory ConfirmationNotMatch(
          {required final String? failedValue,
          required final String? failedConfirmationValue}) =
      _$ConfirmationNotMatchImpl;

  @override
  String? get failedValue;
  String? get failedConfirmationValue;
  @JsonKey(ignore: true)
  _$$ConfirmationNotMatchImplCopyWith<_$ConfirmationNotMatchImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidPhoneImplCopyWith<$Res> {
  factory _$$InvalidPhoneImplCopyWith(
          _$InvalidPhoneImpl value, $Res Function(_$InvalidPhoneImpl) then) =
      __$$InvalidPhoneImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$InvalidPhoneImplCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$InvalidPhoneImpl>
    implements _$$InvalidPhoneImplCopyWith<$Res> {
  __$$InvalidPhoneImplCopyWithImpl(
      _$InvalidPhoneImpl _value, $Res Function(_$InvalidPhoneImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidPhoneImpl(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidPhoneImpl implements InvalidPhone {
  const _$InvalidPhoneImpl({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.invalidPhone(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidPhoneImpl &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidPhoneImplCopyWith<_$InvalidPhoneImpl> get copyWith =>
      __$$InvalidPhoneImplCopyWithImpl<_$InvalidPhoneImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return invalidPhone(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return invalidPhone?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidPhone != null) {
      return invalidPhone(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return invalidPhone(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return invalidPhone?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidPhone != null) {
      return invalidPhone(this);
    }
    return orElse();
  }
}

abstract class InvalidPhone implements StringFailure {
  const factory InvalidPhone({required final String? failedValue}) =
      _$InvalidPhoneImpl;

  @override
  String? get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidPhoneImplCopyWith<_$InvalidPhoneImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidEmailImplCopyWith<$Res> {
  factory _$$InvalidEmailImplCopyWith(
          _$InvalidEmailImpl value, $Res Function(_$InvalidEmailImpl) then) =
      __$$InvalidEmailImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$InvalidEmailImplCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$InvalidEmailImpl>
    implements _$$InvalidEmailImplCopyWith<$Res> {
  __$$InvalidEmailImplCopyWithImpl(
      _$InvalidEmailImpl _value, $Res Function(_$InvalidEmailImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidEmailImpl(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidEmailImpl implements InvalidEmail {
  const _$InvalidEmailImpl({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.invalidEmail(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidEmailImpl &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidEmailImplCopyWith<_$InvalidEmailImpl> get copyWith =>
      __$$InvalidEmailImplCopyWithImpl<_$InvalidEmailImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return invalidEmail(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return invalidEmail?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return invalidEmail?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmail implements StringFailure {
  const factory InvalidEmail({required final String? failedValue}) =
      _$InvalidEmailImpl;

  @override
  String? get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidEmailImplCopyWith<_$InvalidEmailImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidUrlImplCopyWith<$Res> {
  factory _$$InvalidUrlImplCopyWith(
          _$InvalidUrlImpl value, $Res Function(_$InvalidUrlImpl) then) =
      __$$InvalidUrlImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$InvalidUrlImplCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$InvalidUrlImpl>
    implements _$$InvalidUrlImplCopyWith<$Res> {
  __$$InvalidUrlImplCopyWithImpl(
      _$InvalidUrlImpl _value, $Res Function(_$InvalidUrlImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidUrlImpl(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidUrlImpl implements InvalidUrl {
  const _$InvalidUrlImpl({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.invalidUrl(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidUrlImpl &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidUrlImplCopyWith<_$InvalidUrlImpl> get copyWith =>
      __$$InvalidUrlImplCopyWithImpl<_$InvalidUrlImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return invalidUrl(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return invalidUrl?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidUrl != null) {
      return invalidUrl(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return invalidUrl(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return invalidUrl?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidUrl != null) {
      return invalidUrl(this);
    }
    return orElse();
  }
}

abstract class InvalidUrl implements StringFailure {
  const factory InvalidUrl({required final String? failedValue}) =
      _$InvalidUrlImpl;

  @override
  String? get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidUrlImplCopyWith<_$InvalidUrlImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidDateTimeImplCopyWith<$Res> {
  factory _$$InvalidDateTimeImplCopyWith(_$InvalidDateTimeImpl value,
          $Res Function(_$InvalidDateTimeImpl) then) =
      __$$InvalidDateTimeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DateTime failedValue, String pattern});
}

/// @nodoc
class __$$InvalidDateTimeImplCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$InvalidDateTimeImpl>
    implements _$$InvalidDateTimeImplCopyWith<$Res> {
  __$$InvalidDateTimeImplCopyWithImpl(
      _$InvalidDateTimeImpl _value, $Res Function(_$InvalidDateTimeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = null,
    Object? pattern = null,
  }) {
    return _then(_$InvalidDateTimeImpl(
      failedValue: null == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as DateTime,
      pattern: null == pattern
          ? _value.pattern
          : pattern // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$InvalidDateTimeImpl implements InvalidDateTime {
  const _$InvalidDateTimeImpl(
      {required this.failedValue, required this.pattern});

  @override
  final DateTime failedValue;
  @override
  final String pattern;

  @override
  String toString() {
    return 'StringFailure.invalidDateTime(failedValue: $failedValue, pattern: $pattern)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidDateTimeImpl &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue) &&
            (identical(other.pattern, pattern) || other.pattern == pattern));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue, pattern);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidDateTimeImplCopyWith<_$InvalidDateTimeImpl> get copyWith =>
      __$$InvalidDateTimeImplCopyWithImpl<_$InvalidDateTimeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return invalidDateTime(failedValue, pattern);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return invalidDateTime?.call(failedValue, pattern);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidDateTime != null) {
      return invalidDateTime(failedValue, pattern);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return invalidDateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return invalidDateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidDateTime != null) {
      return invalidDateTime(this);
    }
    return orElse();
  }
}

abstract class InvalidDateTime implements StringFailure {
  const factory InvalidDateTime(
      {required final DateTime failedValue,
      required final String pattern}) = _$InvalidDateTimeImpl;

  @override
  DateTime get failedValue;
  String get pattern;
  @JsonKey(ignore: true)
  _$$InvalidDateTimeImplCopyWith<_$InvalidDateTimeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidPersonNameImplCopyWith<$Res> {
  factory _$$InvalidPersonNameImplCopyWith(_$InvalidPersonNameImpl value,
          $Res Function(_$InvalidPersonNameImpl) then) =
      __$$InvalidPersonNameImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$InvalidPersonNameImplCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$InvalidPersonNameImpl>
    implements _$$InvalidPersonNameImplCopyWith<$Res> {
  __$$InvalidPersonNameImplCopyWithImpl(_$InvalidPersonNameImpl _value,
      $Res Function(_$InvalidPersonNameImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidPersonNameImpl(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidPersonNameImpl implements InvalidPersonName {
  const _$InvalidPersonNameImpl({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.invalidPersonName(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidPersonNameImpl &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidPersonNameImplCopyWith<_$InvalidPersonNameImpl> get copyWith =>
      __$$InvalidPersonNameImplCopyWithImpl<_$InvalidPersonNameImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return invalidPersonName(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return invalidPersonName?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidPersonName != null) {
      return invalidPersonName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return invalidPersonName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return invalidPersonName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidPersonName != null) {
      return invalidPersonName(this);
    }
    return orElse();
  }
}

abstract class InvalidPersonName implements StringFailure {
  const factory InvalidPersonName({required final String? failedValue}) =
      _$InvalidPersonNameImpl;

  @override
  String? get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidPersonNameImplCopyWith<_$InvalidPersonNameImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ShortTokenImplCopyWith<$Res> {
  factory _$$ShortTokenImplCopyWith(
          _$ShortTokenImpl value, $Res Function(_$ShortTokenImpl) then) =
      __$$ShortTokenImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$ShortTokenImplCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$ShortTokenImpl>
    implements _$$ShortTokenImplCopyWith<$Res> {
  __$$ShortTokenImplCopyWithImpl(
      _$ShortTokenImpl _value, $Res Function(_$ShortTokenImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$ShortTokenImpl(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$ShortTokenImpl implements ShortToken {
  const _$ShortTokenImpl({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.shortToken(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ShortTokenImpl &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ShortTokenImplCopyWith<_$ShortTokenImpl> get copyWith =>
      __$$ShortTokenImplCopyWithImpl<_$ShortTokenImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return shortToken(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return shortToken?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (shortToken != null) {
      return shortToken(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return shortToken(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return shortToken?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (shortToken != null) {
      return shortToken(this);
    }
    return orElse();
  }
}

abstract class ShortToken implements StringFailure {
  const factory ShortToken({required final String? failedValue}) =
      _$ShortTokenImpl;

  @override
  String? get failedValue;
  @JsonKey(ignore: true)
  _$$ShortTokenImplCopyWith<_$ShortTokenImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidTimeImplCopyWith<$Res> {
  factory _$$InvalidTimeImplCopyWith(
          _$InvalidTimeImpl value, $Res Function(_$InvalidTimeImpl) then) =
      __$$InvalidTimeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$InvalidTimeImplCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$InvalidTimeImpl>
    implements _$$InvalidTimeImplCopyWith<$Res> {
  __$$InvalidTimeImplCopyWithImpl(
      _$InvalidTimeImpl _value, $Res Function(_$InvalidTimeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidTimeImpl(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidTimeImpl implements InvalidTime {
  const _$InvalidTimeImpl({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.invalidTime(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidTimeImpl &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidTimeImplCopyWith<_$InvalidTimeImpl> get copyWith =>
      __$$InvalidTimeImplCopyWithImpl<_$InvalidTimeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return invalidTime(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return invalidTime?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidTime != null) {
      return invalidTime(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return invalidTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return invalidTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidTime != null) {
      return invalidTime(this);
    }
    return orElse();
  }
}

abstract class InvalidTime implements StringFailure {
  const factory InvalidTime({required final String? failedValue}) =
      _$InvalidTimeImpl;

  @override
  String? get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidTimeImplCopyWith<_$InvalidTimeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidDateImplCopyWith<$Res> {
  factory _$$InvalidDateImplCopyWith(
          _$InvalidDateImpl value, $Res Function(_$InvalidDateImpl) then) =
      __$$InvalidDateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? failedValue});
}

/// @nodoc
class __$$InvalidDateImplCopyWithImpl<$Res>
    extends _$StringFailureCopyWithImpl<$Res, _$InvalidDateImpl>
    implements _$$InvalidDateImplCopyWith<$Res> {
  __$$InvalidDateImplCopyWithImpl(
      _$InvalidDateImpl _value, $Res Function(_$InvalidDateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidDateImpl(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidDateImpl implements InvalidDate {
  const _$InvalidDateImpl({required this.failedValue});

  @override
  final String? failedValue;

  @override
  String toString() {
    return 'StringFailure.invalidDate(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidDateImpl &&
            (identical(other.failedValue, failedValue) ||
                other.failedValue == failedValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failedValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidDateImplCopyWith<_$InvalidDateImpl> get copyWith =>
      __$$InvalidDateImplCopyWithImpl<_$InvalidDateImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedValue) empty,
    required TResult Function(String? failedValue) hasWhitespace,
    required TResult Function(String? failedValue) isNotAlphanumeric,
    required TResult Function(String? failedValue, int max) exceedingLength,
    required TResult Function(String? failedValue, int min) lengthTooShort,
    required TResult Function(String? failedValue, int length) wrongLength,
    required TResult Function(String? failedValue) multiline,
    required TResult Function(
            String? failedValue, String? failedConfirmationValue)
        confirmationNotMatch,
    required TResult Function(String? failedValue) invalidPhone,
    required TResult Function(String? failedValue) invalidEmail,
    required TResult Function(String? failedValue) invalidUrl,
    required TResult Function(DateTime failedValue, String pattern)
        invalidDateTime,
    required TResult Function(String? failedValue) invalidPersonName,
    required TResult Function(String? failedValue) shortToken,
    required TResult Function(String? failedValue) invalidTime,
    required TResult Function(String? failedValue) invalidDate,
  }) {
    return invalidDate(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String? failedValue)? empty,
    TResult? Function(String? failedValue)? hasWhitespace,
    TResult? Function(String? failedValue)? isNotAlphanumeric,
    TResult? Function(String? failedValue, int max)? exceedingLength,
    TResult? Function(String? failedValue, int min)? lengthTooShort,
    TResult? Function(String? failedValue, int length)? wrongLength,
    TResult? Function(String? failedValue)? multiline,
    TResult? Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult? Function(String? failedValue)? invalidPhone,
    TResult? Function(String? failedValue)? invalidEmail,
    TResult? Function(String? failedValue)? invalidUrl,
    TResult? Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult? Function(String? failedValue)? invalidPersonName,
    TResult? Function(String? failedValue)? shortToken,
    TResult? Function(String? failedValue)? invalidTime,
    TResult? Function(String? failedValue)? invalidDate,
  }) {
    return invalidDate?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedValue)? empty,
    TResult Function(String? failedValue)? hasWhitespace,
    TResult Function(String? failedValue)? isNotAlphanumeric,
    TResult Function(String? failedValue, int max)? exceedingLength,
    TResult Function(String? failedValue, int min)? lengthTooShort,
    TResult Function(String? failedValue, int length)? wrongLength,
    TResult Function(String? failedValue)? multiline,
    TResult Function(String? failedValue, String? failedConfirmationValue)?
        confirmationNotMatch,
    TResult Function(String? failedValue)? invalidPhone,
    TResult Function(String? failedValue)? invalidEmail,
    TResult Function(String? failedValue)? invalidUrl,
    TResult Function(DateTime failedValue, String pattern)? invalidDateTime,
    TResult Function(String? failedValue)? invalidPersonName,
    TResult Function(String? failedValue)? shortToken,
    TResult Function(String? failedValue)? invalidTime,
    TResult Function(String? failedValue)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidDate != null) {
      return invalidDate(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty value) empty,
    required TResult Function(HasWhitespace value) hasWhitespace,
    required TResult Function(IsNotAlphanumeric value) isNotAlphanumeric,
    required TResult Function(ExceedingLength value) exceedingLength,
    required TResult Function(TooShort value) lengthTooShort,
    required TResult Function(WrongLength value) wrongLength,
    required TResult Function(Multiline value) multiline,
    required TResult Function(ConfirmationNotMatch value) confirmationNotMatch,
    required TResult Function(InvalidPhone value) invalidPhone,
    required TResult Function(InvalidEmail value) invalidEmail,
    required TResult Function(InvalidUrl value) invalidUrl,
    required TResult Function(InvalidDateTime value) invalidDateTime,
    required TResult Function(InvalidPersonName value) invalidPersonName,
    required TResult Function(ShortToken value) shortToken,
    required TResult Function(InvalidTime value) invalidTime,
    required TResult Function(InvalidDate value) invalidDate,
  }) {
    return invalidDate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty value)? empty,
    TResult? Function(HasWhitespace value)? hasWhitespace,
    TResult? Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult? Function(ExceedingLength value)? exceedingLength,
    TResult? Function(TooShort value)? lengthTooShort,
    TResult? Function(WrongLength value)? wrongLength,
    TResult? Function(Multiline value)? multiline,
    TResult? Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult? Function(InvalidPhone value)? invalidPhone,
    TResult? Function(InvalidEmail value)? invalidEmail,
    TResult? Function(InvalidUrl value)? invalidUrl,
    TResult? Function(InvalidDateTime value)? invalidDateTime,
    TResult? Function(InvalidPersonName value)? invalidPersonName,
    TResult? Function(ShortToken value)? shortToken,
    TResult? Function(InvalidTime value)? invalidTime,
    TResult? Function(InvalidDate value)? invalidDate,
  }) {
    return invalidDate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty value)? empty,
    TResult Function(HasWhitespace value)? hasWhitespace,
    TResult Function(IsNotAlphanumeric value)? isNotAlphanumeric,
    TResult Function(ExceedingLength value)? exceedingLength,
    TResult Function(TooShort value)? lengthTooShort,
    TResult Function(WrongLength value)? wrongLength,
    TResult Function(Multiline value)? multiline,
    TResult Function(ConfirmationNotMatch value)? confirmationNotMatch,
    TResult Function(InvalidPhone value)? invalidPhone,
    TResult Function(InvalidEmail value)? invalidEmail,
    TResult Function(InvalidUrl value)? invalidUrl,
    TResult Function(InvalidDateTime value)? invalidDateTime,
    TResult Function(InvalidPersonName value)? invalidPersonName,
    TResult Function(ShortToken value)? shortToken,
    TResult Function(InvalidTime value)? invalidTime,
    TResult Function(InvalidDate value)? invalidDate,
    required TResult orElse(),
  }) {
    if (invalidDate != null) {
      return invalidDate(this);
    }
    return orElse();
  }
}

abstract class InvalidDate implements StringFailure {
  const factory InvalidDate({required final String? failedValue}) =
      _$InvalidDateImpl;

  @override
  String? get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidDateImplCopyWith<_$InvalidDateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
